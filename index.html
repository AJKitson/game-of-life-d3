<!DOCTYPE html>
<html>
  <head>
    <script src="bower_components/d3/d3.min.js" charset="utf-8"></script>
    <script src="bower_components/underscore/underscore-min.js" charset="utf-8"></script>
    <script src="CellPopulation.js"></script>
    <style type="text/css">
      svg {
        border: 1px solid #666;
      }
    </style>
  </head>
  <body>
    <div class="buttons">
      <button class="start">Start</button>
    </div>
    <div id="world"></div>
    <script type="text/javascript">
    /*TODO
    [] switch to d3 scales
    [] have color be brighter on creation, gray as it ages (e.g. for static formations)
    [] maybe have background color change with the number of cells
    [] speed up and slow down the generation speed
    [] do some profiling
    [] pan and zoom 
    [] clean up: global variables, not creating all our helper fns w/each tick, etc.
    [] make hexagonal?
    [] implement CellPopulation as a SICP-style stream of generations, or using ES6 generators
    */

      var createNewGeneration = function (world) {
        // A cell's fate hinges entirely on how many living
        // neighbors it has. This function counts them.
        var livingNeighborCount = function (cell) {
          return world.getNeighbors(cell)
            .filter(world.isAlive)
            .length;
        };

        // A living cell continues to live if it has 2 or 3 
        // living neighbors. It dies otherwise. A dead cell 
        // comes alive in the next generation if it has exactly
        // 3 living neighbors. Otherwise it remains dead.
        var aliveInNextGeneration = function (cell) {
          var livingNeighbors = livingNeighborCount(cell);
          return world.isAlive(cell) 
                 ? livingNeighbors === 2 || livingNeighbors === 3
                 : livingNeighbors === 3;
        };

        // Get all the cells that might be alive next round (the 
        // living cells and their neighbors) and then filter 
        // to just those that actually are alove in the next generation.
        var newSeed = world.liveCellsAndNeighbors().filter(aliveInNextGeneration);
        return CellPopulation(newSeed);
      };


      var scaleCoordUp = function (c) {
        return settings.cellSize * c + settings.cellSize / 2;
      }  

      var display = function (cells) {
        var size = settings.cellSize;
        var cells = d3.select('svg')
          .selectAll('circle')
          .data(cells, function (d) { return d; })
          .style('fill', '#45e')
          

        cells.enter()
          .append('circle')
          .attr('class', 'cell')
          .attr('r', size / 2 + 'px')
          .attr('cx', function (d) { return scaleCoordUp(d[0]) + 'px'; }) //what was I thinking here?
          .attr('cy', function (d) { return scaleCoordUp(d[1]) + 'px'; })
          .style('fill', '#45e')

        cells.exit()
          .remove();
      };

      var wheelOfTime = function (world) {
        settings.world = createNewGeneration(world);
        display(world.liveCells());
        setTimeout(function () {
          wheelOfTime(settings.world);
        }, settings.tick); 
      };

      var coordsToCell = function (x, y) {
        var scaleDown = function (c) { return Math.floor(c / settings.cellSize); }
        return [scaleDown(x), scaleDown(y)];
      }
    
      var settings = {
        cellSize: 10,
        worldSize: 1000,
        startingFormation: 'Acorn',
        world: CellPopulation([]),
        tick: 60
      };

      var formations = {
        'Acorn' : [[5, 5], [6, 5], [6, 3], [8, 4], [9, 5], [10, 5], [11, 5]],
        'R-pentomino': [[1, 0], [2, 0], [0, 1], [1, 1], [1, 2]],
        'Diehard': [[6, 0], 
                    [0, 1], [1, 1], 
                    [1, 2], [5, 2], [6, 2], [7, 2]],
        'Glider Gun': [[24, 0],
                      [22, 1], [24, 1],
                      [12, 2], [13, 2], [20, 2], [21, 2], [34, 2], [35, 2],
                      [11, 3], [15, 3], [20, 3], [21, 3], [34, 3], [35, 3],
                      [0, 4], [1, 4], [10, 4], [16, 4], [20, 4], [21, 4], 
                      [0, 5], [1, 5], [10, 5], [14, 5], [16, 5], [17, 5], [22, 5], [24, 5],
                      [10, 6], [16, 6], [24, 6],
                      [11, 7], [15, 7],
                      [12, 8], [13, 8]]
      }

      var setup = function () {
        //setup buttons
        d3.select('.start')
          .on('click', start)

        d3.select('.buttons')
          .selectAll('.buttons .formation')
          .data(Object.keys(formations))
          .enter()
          .append('button')
          .attr('class', 'formation')
          .text(function (d) { return d; })
          .on('click', function (d) {
            settings.world = CellPopulation(formations[d].map(function (cell) {  //position at middle (hacky...)
              return [ cell[0] + (settings.worldSize / 2) / settings.cellSize, 
                       cell[1] + (settings.worldSize / 2) / settings.cellSize ]; 
            }));
            display(settings.world.liveCells());
          });

        //setup board
        d3.select('#world').append('svg')
          .attr('width', settings.worldSize + 'px')
          .attr('height', settings.worldSize + 'px')
          .on('click', function (e) {
            var xy = d3.mouse(this);
            var cell = coordsToCell(xy[0], xy[1]);
            settings.world.toggleCell(cell);
            display(settings.world.liveCells());
          });
      };

      var start = function () {
        settings.world = settings.world || CellPopulation(formations[settings.defaultFormation]);
        wheelOfTime(settings.world);
      };

      setup();


    </script>
  </body>
</html>
